when angular see an * beforee a directive name, it creates a template ad wrappes the
view of the strutural directive and moves the structural directive on that template.
and in that template wrapper the strucutral directive is used as an attribute directive.



<!-- ng for -->
Item : The local template variable that represents each item in the array.
Items: The array or iterable being iterated over.


By default, *ngFor uses object identity to detect changes when the array is modified. This can lead to inefficient
re-rendering. To improve performance, use the trackBy function to identify unique items.

trackById(index: number, item: any): number { return item.id; // or a unique property of the item


<!-- ng If -->
condition: A Boolean expression that evaluates to true or false. If it’s true, the content is rendered; if false, the
content is removed from the DOM.


Using *ngIf with else
You can use the else clause to display an alternative template when the condition is false:

<div *ngIf="isLoggedIn; else loggedOutTemplate">
  Welcome back, user!
</div>
<ng-template #loggedOutTemplate>
  <p>Please log in to continue.</p>
</ng-template>

#loggedOutTemplate is an ng-template reference that provides a fallback template.

<!-- ngSwitch -->

2. Basic Syntax and Structure
*ngSwitch is used with the [ngSwitch] directive on a parent container and *ngSwitchCase for each possible condition. An
*ngSwitchDefault can be used for fallback content.

3. How It Works
[ngSwitch]: Evaluates the given expression.
*ngSwitchCase: Renders its associated content if its value matches the value of [ngSwitch].
*ngSwitchDefault: Renders if none of the *ngSwitchCase values match.

4. Using *ngSwitch with Different Types of Cases
*ngSwitch can handle cases with different types of values such as strings, numbers, or even variables.
html
<div [ngSwitch]="userRole">
  <div *ngSwitchCase="'admin'">Welcome, Admin!</div>
  <div *ngSwitchCase="'user'">Hello, User!</div>
  <div *ngSwitchCase="'guest'">Greetings, Guest!</div>
  <div *ngSwitchDefault>Access Restricted</div>
</div>


<!-- one Directive per element  -->
An intuitive way to do that is to put both an *ngFor and an *ngIf on the same element. However, since both *ngFor and
*ngIf are structural directives, this would be treated as an error by the compiler. You may apply only one structural
directive to an element.


<!-- custom directive -->
ElementRef: Provides a reference to the element the directive is applied to.
Renderer2: Safely manipulates DOM properties (better practice than directly accessing nativeElement).
@HostListener: Listens to host element events and triggers functions.

Use the directive in a template:
html
<p appHighlight="lightblue">Hover over this text to see the effect!</p>

<!-- creating a structural directive.  -->
so when creating a structural directive we need two things.
1. access to the dom element we chage to modify
2. A place where we want to add or remove the DOM element





<!-- herarchical injector -->
When a component or service requests a dependency:
Angular first looks for the dependency in the component's injector.
If not found, it searches up the hierarchy until it reaches the root injector.
If the service is not found in any injector, Angular throws an error indicating an unresolvable dependency.




4. Providing Services at Different Levels
AppModule (Root Level): Services provided here are singleton and shared across the entire app.
NgModule (Feature Module): Providing services in feature modules can scope them to the module, avoiding shared instances
with other modules.
Component Level: Providing services at the component level creates new instances each time the component is used. This
approach is useful for scenarios requiring unique service instances for each component.




<!-- Ng module -->



Module Initialization:
When an Angular application is bootstrapped, the module metadata is parsed and the module system sets up the components,
directives, and services declared in the module.

Dependency Injection:
The services specified in the providers array are registered in the module’s DI system. This makes them available to be
injected into components or other services within the module.

Module Initialization in Child Modules:
When a child module is loaded via lazy loading or as a part of routing, its @NgModule metadata is also processed, with
its own set of dependencies and services.





<!-- Host -->
hosr psudo-calss: This example ensures that the component itself, not the inner elements, is styled with a border.

host function: This applies a background color to the host element only when it has the active class.

:host-context() Pseudo-class: If any ancestor of the component (e.g.,

<body>) has the dark-mode class, the component will inherit these styles.

  How :host and :host-context Differ
  :host: Only applies styles directly to the host element itself.
  :host-context: Applies styles when a specific condition is found in an ancestor or surrounding context.
  Key Points to Remember
  :host ensures styles do not leak out of the component, while :host-context provides adaptability based on external
  factors.
  These selectors help maintain encapsulation but offer controlled interaction with the parent context or the
  component's own state.



  <!-- NgPural -->

  Key Points:
Works with the ngPlural directive.
You define plural cases using ngPluralCase with specific keywords like =0, =1, few, many, other, etc.
Follows the CLDR (Unicode Common Locale Data Repository) for language-specific rules.<div [ngPlural]="messages.length"> <ng-template ngPluralCase="=0">No messages</ng-template> <ng-template ngPluralCase="=1">One message</ng-template> <ng-template ngPluralCase="few">A few messages</ng-template> <ng-template ngPluralCase="other">Several messages</ng-template> </div>



<!-- Angulae Elemenst  -->
2. Use Cases and Benefits
Integrate Angular components into non-Angular projects.
Migrate legacy applications incrementally.
Share Angular functionality as standalone web components across different projects.

so what they do is that they  provide a way to annotate or 
modify the structure the behaviour with changing the source code directly 

so there essential functions that are applied using the  @ symbol are they are called at runtime

To enable them, you need to set the "experimentalDecorators": true flag in your tsconfig.json file




so whena class in instanciated its contructor is the one that is been called first 







I began with the basics of Angular, exploring components and their structure. 
I then looked into rendering dynamic data, setting dynamic properties and attributes, and also some  handling events.

I also looked into how data models communicate with view templates, and one interesting I noticed was Angular's change detection mechanism

Which basically checks for changes in the component data and updates the view emplate.
and these chnage can be triggred manully or through some asynchronous events. 

and also the change dection involves a tree of componenets where each conponenets tracks chnages to its properties 
 and it uses zones for that, specifically zone.js, to intercept asynchronous operations like user intractions or http request.

but the angular 18 alows you to  handle change detection without the Zone.js. which signals is the alternative
so with the signals they directly notify Angular of data changes without relying on the zone mechanism. but am yet to dive more into that. 

 also realized the change detection is based on unidirectional data flow. which bassically mean data flowing in one direction so when data changes in a component, 
 Angular updates the view to reflect those changes. it is done, by triggering the change detection cycle, which check each componenet in a specific sequence.

also looked into how angular check for chnages.
1. checks the componenets properties i.e checking  if properties on each component have changed.
2. Checks Input Properties of Child Components.
3. the expressions in the template are evaluated to see if they produce a different result than before.


Also Looked into some change detection startgies 

and realzied angular has two main change detection strategies, which is the default and the onPush:

so bassically with the default strategy, Angular will check the entire component tree when a change detection cycle is triggered and 
i realized that is generally the default setting for most components.

and the second is the OnPush: 
and with that strategy, Angular skips the component unless:
The component’s inputs have changed or 
An event is triggered within the component (like a user interaction).
A manual change detection cycle is triggered.

and i noticed the onpush improve performance because Angular only re-renders the component when necessary that is reducing the number of checks.






Yesterday, I continued exploring Angular’s change detection system, and I looked into some directive specifically the structual directive and how the syntax has chnage base  on the version of
angular, how the legacy version were using the ngif and the latest version uses @if and also introducing the @else 
i also look into some decorators specifically on some property decorators like @Input and @Output and their responsiveness to change detection.

I realized that when passing complex data types, such as arrays or objects, to @Input properties, you've to be cautious about mutations. 
because the angular’s change detection primarily relies on reference comparisons rather than deep property checks within objects or arrays. 
which bassically means that the internal changes to an array or object won’t trigger change detection unless the reference itself changes.

so i tried my hand on it and i realized ensure Angular detects updates particularly in cases like that, you can reassign  a new array or object reference 
after the modifications and it will notify Angular of the change, ensuring the change detection picks it up.

so that will be all for me. 




Onchanges: it is called before the oninit if you.ve an input value 
triggers whenever any input property changes.

ngOnInit method runs after Angular has initialized all the component inputs with their initial values

ngDoCheck lifecycle hook is called every time Angular runs change detection for a component. I realized it is very useful when implementing
a custom change detection logic like detecting changes in complex data structures, 
such as objects and arrays since internal changes to an array or object won’t trigger change detection unless the reference itself changes.


ngAfterViewInit is a lifecycle hook that is called after Angular has fully initialized a component's view.
 It s also useful in dom manupulations since it manupulates the elements in the components 
since the view is fully initialized. It is also use in intergrating third party-libraries that requires the dom. 

ngAfterContentInit method runs once after all the children nested inside the component (it’s content) have been initialized. 
so cases where components accept dynamic content through content projection, 
the ngAfterContentInit allows for the initialization of any logic that depends on this content.


ngAfterViewChecked lifecycle hook is called after every change detection cycle when the component's view has been checked.
his hook is primarily used to respond to changes in the component's view after the view has been checked


ngAfterContentChecked lifecycle hook is called after every change detection cycle when the component’s content has been checked. 

so i noticed some similairities with the ngAfterContentChecked and the ngAfterViewChecked and realizd that the ngAfterContentChecked handles 
changes specifically in the content projected into your component. 
For example, if you have a parent component projecting a dynamic list of items and you want to react whenever those items change, you can use that.
while the ngAfterViewChecked react to changes in the entire view of the component, including all its children. 





so i looked in to dependancy inject in angular, and learnt it bassically allows us to inject services arrow compoenents........
i also descovered if you inject a service in a  componenet this something called the injector which  is responsible for 
facilitating the interaction between the dependancy provider and the dependancy consumer 
i.e the injector creates an instance of the dependancy and inject it into  a constructor in the component 
const component - new  component ()







two main types ( model injector Hierarchy andelement injector Hierarchy)
















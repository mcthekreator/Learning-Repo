so what they do is that they  provide a way to annotate or 
modify the structure the behaviour with changing the source code directly 

so there essential functions that are applied using the  @ symbol are they are called at runtime

To enable them, you need to set the "experimentalDecorators": true flag in your tsconfig.json file




so whena class in instanciated its contructor is the one that is been called first 







I began with the basics of Angular, exploring components and their structure. 
I then looked into rendering dynamic data, setting dynamic properties and attributes, and also some  handling events.

I also looked into how data models communicate with view templates, and one interesting I noticed was Angular's change detection mechanism

Which basically checks for changes in the component data and updates the view emplate.
and these chnage can be triggred manully or through some asynchronous events. 

and also the change dection involves a tree of componenets where each conponenets tracks chnages to its properties 
 and it uses zones for that, specifically zone.js, to intercept asynchronous operations like user intractions or http request.

but the angular 18 alows you to  handle change detection without the Zone.js. which signals is the alternative
so with the signals they directly notify Angular of data changes without relying on the zone mechanism. but am yet to dive more into that. 

 also realized the change detection is based on unidirectional data flow. which bassically mean data flowing in one direction so when data changes in a component, 
 Angular updates the view to reflect those changes. it is done, by triggering the change detection cycle, which check each componenet in a specific sequence.

also looked into how angular check for chnages.
1. checks the componenets properties i.e checking  if properties on each component have changed.
2. Checks Input Properties of Child Components.
3. the expressions in the template are evaluated to see if they produce a different result than before.


Also Looked into some change detection startgies 

and realzied angular has two main change detection strategies, which is the default and the onPush:

so bassically with the default strategy, Angular will check the entire component tree when a change detection cycle is triggered and 
i realized that is generally the default setting for most components.

and the second is the OnPush: 
and with that strategy, Angular skips the component unless:
The component’s inputs have changed or 
An event is triggered within the component (like a user interaction).
A manual change detection cycle is triggered.

and i noticed the onpush improve performance because Angular only re-renders the component when necessary that is reducing the number of checks.






Yesterday, I continued exploring Angular’s change detection system, and I looked into some directive specifically the structual directive and how the syntax has chnage base  on the version of
angular, how the legacy version were using the ngif and the latest version uses @if and also introducing the @else 
i also look into some decorators specifically on some property decorators like @Input and @Output and their responsiveness to change detection.

I realized that when passing complex data types, such as arrays or objects, to @Input properties, you've to be cautious about mutations. 
because the angular’s change detection primarily relies on reference comparisons rather than deep property checks within objects or arrays. 
which bassically means that the internal changes to an array or object won’t trigger change detection unless the reference itself changes.

so i tried my hand on it and i realized ensure Angular detects updates particularly in cases like that, you can reassign  a new array or object reference 
after the modifications and it will notify Angular of the change, ensuring the change detection picks it up.

so that will be all for me. 




Onchanges: it is called before the oninit if you.ve an input value 
triggers whenever any input property changes.

ngOnInit method runs after Angular has initialized all the component inputs with their initial values

ngDoCheck lifecycle hook is called every time Angular runs change detection for a component. I realized it is very useful when implementing
a custom change detection logic like detecting changes in complex data structures, 
such as objects and arrays since internal changes to an array or object won’t trigger change detection unless the reference itself changes.


ngAfterViewInit is a lifecycle hook that is called after Angular has fully initialized a component's view.
 It s also useful in dom manupulations since it manupulates the elements in the components 
since the view is fully initialized. It is also use in intergrating third party-libraries that requires the dom. 

ngAfterContentInit method runs once after all the children nested inside the component (it’s content) have been initialized. 
so cases where components accept dynamic content through content projection, 
the ngAfterContentInit allows for the initialization of any logic that depends on this content.


ngAfterViewChecked lifecycle hook is called after every change detection cycle when the component's view has been checked.
his hook is primarily used to respond to changes in the component's view after the view has been checked


ngAfterContentChecked lifecycle hook is called after every change detection cycle when the component’s content has been checked. 

so i noticed some similairities with the ngAfterContentChecked and the ngAfterViewChecked and realizd that the ngAfterContentChecked handles 
changes specifically in the content projected into your component. 
For example, if you have a parent component projecting a dynamic list of items and you want to react whenever those items change, you can use that.
while the ngAfterViewChecked react to changes in the entire view of the component, including all its children. 





so i looked in to dependancy inject in angular, and learnt it bassically allows us to inject services arrow compoenents........
i also descovered if you inject a service in a  componenet this something called the injector which  is responsible for 
facilitating the interaction between the dependancy provider and the dependancy consumer 
i.e the injector creates an instance of the dependancy and inject it into  a constructor in the component 
const component - new  component ()







two main types ( model injector Hierarchy andelement injector Hierarchy)















Okay, so for last friday I looked into ngModules
so basicallly ngModule is a class that is uesd to orginzed angular application into cohesive blocks.
It takes a metadata object that describes how to compile a 
component's template and how to create an injector at runtime 

so I looked into the properties in the metadata object 

 1. declarations is an array contains the components, directives, and pipes that belong to the module. 
i descovered Items declared in declarations are private to that module unless they are exported.
 you can declare a component, directive, or pipe in only one module. Declaring it in multiple modules causes a compilation error

another property is 
2. imports which is also an array that contains imported modules 
e.g will be how we import the commonmodule in our componenets into order to access directives like ngif etc
3. exports which is also and array that is use to make declarations from a modle to be avaliable to other modules 
4. providers is also an array registers services that the module uses. which i find it intresting so I will be deeping more into that 
5. bootstrap is also a property that only used in the root module (typically AppModule). 
It specifies the root component that Angular should bootstrap when the application starts.


Every Angular application has at least one module i.e root module also known as the app moudule

so the root module provides the entry point for the application and bootstraps the root component. 

also realized root module is somehow enough when working in an application with few components. 
but when working on larger applications or as the application grows, you've to refactor the root 
module into feature modules then import them into the root module.

the feature module delivers a cohesive set of functionality focused on a specific application need 
such as a user workflow, routing, or forms. While you can do everything within the root module, 
feature modules help you partition the application into focused areas which bassically makes the application structure clear and scalable.




declarations: Components, directives, and pipes that belong to the module.
imports: Other modules that this module needs.
exports: Components, directives, and pipes that can be used in other modules.
providers: Services available throughout the module.
bootstrap: The root component for bootstrapping the app (used only in the root module).









A feature module is an organizational best practice, as opposed to a concept of the core Angular API. 
A feature module delivers a cohesive set of functionality focused on a specific application 
need such as a user workflow, routing, or forms. While you can do everything within the root module, 
feature modules help you partition the application into focused areas

 takes a metadata object that describes how to compile a 
component's template and how to create an injector at runtime. It identifies the module's own 
components, directives, and pipes, making some of them public, through the exports property, 
so that external components can use them. @NgModule can also add service providers to the application dependency injectors.






providing dependancies in modules
shared modules
core modules
lazy-loaded modules
signleton service






NgModule: helps orginze the complex relationship between views such as componenets and directives to data providers such as servics and guards. 
I works by allowing you to define all these relationships in a single file.

the ngmodule metadata 
1. declarration: where yuo will put componenets, directives or pipes and it will be privatly avaliable to that module
2. Expotrs: components are privte by defualt but become public when you add them to export 
3. imports: other modules get access to it by importing them in thier owen metadata 

NB: declaratins, import and exports defined the relationship between components and how their shared between diffrent ngmodules 

4. boostrap: it defines a component which is initially use to load your application. By default it is the app compoenent which is created b yht angula cli 
5. providers: here is where you register data providers such as services and guards that can be injected in the component within the module. 
The injectable class will  be avalbale to any  componenets in the moduleot any module that imports it. 







So yesterday I looked into angular routing 
In a client-side web application, such as a single-page application (SPA) built with Angular, 
routing allows users to navigate between different views without actually loading a new HTML page from the server. 
Instead, the application dynamically updates the content in the browser by loading the necessary components and data based on the requested route

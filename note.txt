so what they do is that they  provide a way to annotate or 
modify the structure the behaviour with changing the source code directly 

so there essential functions that are applied using the  @ symbol are they are called at runtime

To enable them, you need to set the "experimentalDecorators": true flag in your tsconfig.json file

so whena class in instanciated its contructor is the one that is been called first 


I began with the basics of Angular, exploring components and their structure. 
I then looked into rendering dynamic data, setting dynamic properties and attributes, and also some  handling events.

I also looked into how data models communicate with view templates, and one interesting I noticed was Angular's change detection mechanism

Which basically checks for changes in the component data and updates the view emplate.
and these chnage can be triggred manully or through some asynchronous events. 

and also the change dection involves a tree of componenets where each conponenets tracks chnages to its properties 
 and it uses zones for that, specifically zone.js, to intercept asynchronous operations like user intractions or http request.

but the angular 18 alows you to  handle change detection without the Zone.js. which signals is the alternative
so with the signals they directly notify Angular of data changes without relying on the zone mechanism. but am yet to dive more into that. 

 also realized the change detection is based on unidirectional data flow. which bassically mean data flowing in one direction so when data changes in a component, 
 Angular updates the view to reflect those changes. it is done, by triggering the change detection cycle, which check each componenet in a specific sequence.

also looked into how angular check for chnages.
1. checks the componenets properties i.e checking  if properties on each component have changed.
2. Checks Input Properties of Child Components.
3. the expressions in the template are evaluated to see if they produce a different result than before.


Also Looked into some change detection startgies 

and realzied angular has two main change detection strategies, which is the default and the onPush:

so bassically with the default strategy, Angular will check the entire component tree when a change detection cycle is triggered and 
i realized that is generally the default setting for most components.

and the second is the OnPush: 
and with that strategy, Angular skips the component unless:
The component’s inputs have changed or 
An event is triggered within the component (like a user interaction).
A manual change detection cycle is triggered.

and i noticed the onpush improve performance because Angular only re-renders the component when necessary that is reducing the number of checks.






Yesterday, I continued exploring Angular’s change detection system, and I looked into some directive specifically the structual directive and how the syntax has chnage base  on the version of
angular, how the legacy version were using the ngif and the latest version uses @if and also introducing the @else 
i also look into some decorators specifically on some property decorators like @Input and @Output and their responsiveness to change detection.

I realized that when passing complex data types, such as arrays or objects, to @Input properties, you've to be cautious about mutations. 
because the angular’s change detection primarily relies on reference comparisons rather than deep property checks within objects or arrays. 
which bassically means that the internal changes to an array or object won’t trigger change detection unless the reference itself changes.

so i tried my hand on it and i realized ensure Angular detects updates particularly in cases like that, you can reassign  a new array or object reference 
after the modifications and it will notify Angular of the change, ensuring the change detection picks it up.

so that will be all for me. 




Onchanges: it is called before the oninit if you.ve an input value 
triggers whenever any input property changes.

ngOnInit method runs after Angular has initialized all the component inputs with their initial values

ngDoCheck lifecycle hook is called every time Angular runs change detection for a component. I realized it is very useful when implementing
a custom change detection logic like detecting changes in complex data structures, 
such as objects and arrays since internal changes to an array or object won’t trigger change detection unless the reference itself changes.


ngAfterViewInit is a lifecycle hook that is called after Angular has fully initialized a component's view.
 It s also useful in dom manupulations since it manupulates the elements in the components 
since the view is fully initialized. It is also use in intergrating third party-libraries that requires the dom. 

ngAfterContentInit method runs once after all the children nested inside the component (it’s content) have been initialized. 
so cases where components accept dynamic content through content projection, 
the ngAfterContentInit allows for the initialization of any logic that depends on this content.


ngAfterViewChecked lifecycle hook is called after every change detection cycle when the component's view has been checked.
his hook is primarily used to respond to changes in the component's view after the view has been checked


ngAfterContentChecked lifecycle hook is called after every change detection cycle when the component’s content has been checked. 

so i noticed some similairities with the ngAfterContentChecked and the ngAfterViewChecked and realizd that the ngAfterContentChecked handles 
changes specifically in the content projected into your component. 
For example, if you have a parent component projecting a dynamic list of items and you want to react whenever those items change, you can use that.
while the ngAfterViewChecked react to changes in the entire view of the component, including all its children. 





so i looked in to dependancy inject in angular, and learnt it bassically allows us to inject services arrow compoenents........
i also descovered if you inject a service in a  componenet this something called the injector which  is responsible for 
facilitating the interaction between the dependancy provider and the dependancy consumer 
i.e the injector creates an instance of the dependancy and inject it into  a constructor in the component 
const component - new  component ()







two main types ( model injector Hierarchy andelement injector Hierarchy)















Okay, so for last friday I looked into ngModules
so basicallly ngModule is a class that is uesd to orginzed angular application into cohesive blocks.
It takes a metadata object that describes how to compile a 
component's template and how to create an injector at runtime 

so I looked into the properties in the metadata object 

 1. declarations is an array contains the components, directives, and pipes that belong to the module. 
i descovered Items declared in declarations are private to that module unless they are exported.
 you can declare a component, directive, or pipe in only one module. Declaring it in multiple modules causes a compilation error

another property is 
2. imports which is also an array that contains imported modules 
e.g will be how we import the commonmodule in our componenets into order to access directives like ngif etc
3. exports which is also and array that is use to make declarations from a modle to be avaliable to other modules 
4. providers is also an array registers services that the module uses. which i find it intresting so I will be deeping more into that 
5. bootstrap is also a property that only used in the root module (typically AppModule). 
It specifies the root component that Angular should bootstrap when the application starts.


Every Angular application has at least one module i.e root module also known as the app moudule

so the root module provides the entry point for the application and bootstraps the root component. 

also realized root module is somehow enough when working in an application with few components. 
but when working on larger applications or as the application grows, you've to refactor the root 
module into feature modules then import them into the root module.

the feature module delivers a cohesive set of functionality focused on a specific application need 
such as a user workflow, routing, or forms. While you can do everything within the root module, 
feature modules help you partition the application into focused areas which bassically makes the application structure clear and scalable.




declarations: Components, directives, and pipes that belong to the module.
imports: Other modules that this module needs.
exports: Components, directives, and pipes that can be used in other modules.
providers: Services available throughout the module.
bootstrap: The root component for bootstrapping the app (used only in the root module).









A feature module is an organizational best practice, as opposed to a concept of the core Angular API. 
A feature module delivers a cohesive set of functionality focused on a specific application 
need such as a user workflow, routing, or forms. While you can do everything within the root module, 
feature modules help you partition the application into focused areas

 takes a metadata object that describes how to compile a 
component's template and how to create an injector at runtime. It identifies the module's own 
components, directives, and pipes, making some of them public, through the exports property, 
so that external components can use them. @NgModule can also add service providers to the application dependency injectors.






providing dependancies in modules
shared modules
core modules
lazy-loaded modules
signleton service






NgModule: helps orginze the complex relationship between views such as componenets and directives to data providers such as servics and guards. 
I works by allowing you to define all these relationships in a single file.

the ngmodule metadata 
1. declarration: where yuo will put componenets, directives or pipes and it will be privatly avaliable to that module
2. Expotrs: components are privte by defualt but become public when you add them to export 
3. imports: other modules get access to it by importing them in thier owen metadata 

NB: declaratins, import and exports defined the relationship between components and how their shared between diffrent ngmodules 

4. boostrap: it defines a component which is initially use to load your application. By default it is the app compoenent which is created b yht angula cli 
5. providers: here is where you register data providers such as services and guards that can be injected in the component within the module. 
The injectable class will  be avalbale to any  componenets in the moduleot any module that imports it. 




shared module which is also known as the widget module its like the feature module but they add all their declarations to the exports
so they can be distrubuted to other modules, 
Realized it very helpful when working with spinners or icons, basically things tha will be used globally throught the project   

Core Module: holds singleton services and application-wide logic and acts as a centralized functionality source.
 I also realized It is only imported into the root AppModule to 
prevent redundant or conflicting instances because it can be  accidentally imported into other feature modules.
when working with it, using the @Optional() and @SkipSelf() in the constructor ensure that 
Angular checks if the Core Module has already been loaded in the root module, preventing re-imports that might cause multiple instances of singletons.

Lazy loading allows Angular to load specific modules only when they are needed, such as when the user navigates to a certain route
and it optimizes application performance by reducing the initial load time.
and its actually useful when working with feature modules that aren’t needed immediately when the application loads
or some part of the application that is being accessed based on user interaction. 
It is linked to routing so today I will be looking deep into that and routing as well. 





so the router module helps us navigate between diffrent view without actually loading a new HTML page from the server. 
Also tried myy hands on come parent child route which is actaully a go to when working with dynamic URL parameter 
Also tried my hands on some parent child routing and also some 404 error page. 

also practiced on some guards, which actaully helps us for controlling access to diffrenet route of our application . 
it used interfaces that implement to change the behaviour of the router

1. the canActivate - Controls whether a route can be accessed or activated by a user.
so with this it has a route and state as parameters and
the route: provides route informatin, such as query params and 
the state: representes the router state snapshot which contains the full url for which the navigation was initiated 
and also it returns a boolean or a urltree.
When a user tries to navigate to a route protected by CanActivate, Angular pauses the navigation and calls the guard. 
If CanActivate returns true, navigation proceeds. If it returns false or a UrlTree, navigation is either stopped or redirected

2. the CanActivateChild - Controls access to child routes within a parent route.
so its just like the CanActivate but specifically for child routes. 
so when parent route is accessible, but some child routes need additional checks, like roles or permissions





looked into router module, navigate between different views without actually loading a new HTML page from the server. 
the application dynamically updates the content in the browser by loading the necessary components and data based on the requested route

I also tried my hand on some parent child route which is actaully a go to when working with dynamic  URL parameter.
so when working with the child route, it listens to chnage in the URL paerameter and renders its corresponing page.
so with that also you can use the activated route, which basically allows us to listen to chnage changes in the router.

Also tried ma hands on an 404 error page, which with that in your router config. the path key the values is going to be ** and the conponents key value will be the coressponding component 

Lazyloading: you configure the lazy loading in the rout config, and set the path. and with the loadehildern property simply means that the child routes should be loaded in an
asynchronous way, s
in the loadedchildren, use dynamic import which bassiaclyis using the import as the funtion 

loadchildren: a an async function which returns a promise that when successfully evaluated give back it corresponing module. 



also looked into gaurds its an angular service that has some special interfaces that implement to change the behaviour of the router
and the comman use case is to protect the rout from unauthorized users 

one of the interfaces of the guard is the canActivate, it returns a boolean which bassiacly is boolean with can be  a primitive or and observable or a promise
and if its an observable it will automatically subscribe for you. 

  




with bassically give information about the state of the route. 
and for the gaurd to work  















CanActivateChild for Nested Route Security: Use CanActivateChild guards on parent routes to enforce guard logic across all child routes. This is particularly useful for admin or settings pages where access is restricted.






3. the CanDeactivet - Determines if a user can navigate away from the current route so its basically
 prevents users from leaving a route without fulfilling certain conditions. It is very useful when working with forms 
 or editable pages cos it could prevent the users from accidentally navigating when their unsave change. 
 so it also returns a boolean or observable. so if it returns true the navigation proceeds and if it retuns false then it is blocked 
 one of it use case that i tried is also to prompt a users when trying to navigate away from the page 

4. the Canload - controls access to lazy-loaded modules. It's often used for protecting routes based on user roles or authentication status.
Returns a boolean or Observable<boolean>.
If true, the module loads; if false, loading is blocked.
CanLoad doesn’t have access to route parameters (like :id) 
beacuse it is designed to make decisions when loading the module
and at that state there's no specific route context or parameters that are available because the module and its routes haven't been parsed or initialized.
so it’s best suited for routes without parameters.

5. resolvers, which can also preload data into your route so basically it retrieve data before the route activates
It is similar to the canActivate but it returns a data that want to be avaliable where the route is being navigated to. 
allows data to be fetched and made available to components without having to loaders or  spinners.

The resolver retrieves the data and provides it via the ActivatedRoute's data property.
If data cannot be fetched, navigation can be redirected or an error can be shown.

NB
when working with multiple gaurds on a router,  
order of guards in the route configuration impacts which guard Angular evaluates first. 
If the first guard fails, Angular cancels navigation without checking the next guard